import { supabaseAdmin } from './supabase'
import {
  AvatarSession,
  CreateAvatarSessionData,
  UpdateAvatarSessionData,
  GeneratedQuestion,
  SessionConfig,
  TranscriptEntry,
  SupportedLanguageCode,
  SUPPORTED_LANGUAGES
} from './avatar-types'

class AvatarService {
  /**
   * Generate unique questions from knowledge base for a session
   */
  async generateQuestionsFromKnowledgeBase(
    companyId: string,
    config: SessionConfig
  ): Promise<GeneratedQuestion[]> {
    try {
      console.log('ü§ñ Generating questions from knowledge base...')

      // For now, always use fallback questions since knowledge_documents table may not exist
      // This ensures the avatar system works out of the box
      console.log('üìö Using fallback questions for demo purposes')
      return this.generateFallbackQuestions(config.duration_minutes)

    } catch (error) {
      console.error('‚ùå Error generating questions:', error)
      return this.generateFallbackQuestions(config.duration_minutes)
    }
  }

  /**
   * Generate questions using AI based on knowledge base content
   */
  private async generateQuestionsWithAI(
    documents: any[],
    config: SessionConfig
  ): Promise<GeneratedQuestion[]> {
    try {
      // Estimate questions needed (one every 30 seconds on average)
      const questionsNeeded = Math.max(10, Math.ceil(config.duration_minutes * 2))

      // Prepare content for AI
      const knowledgeContent = documents
        .map(doc => `Title: ${doc.title}\nContent: ${doc.content}`)
        .join('\n\n')

      const prompt = `Based on the following knowledge base content, generate ${questionsNeeded} diverse questions for employee training.

Knowledge Base:
${knowledgeContent}

Requirements:
- Generate exactly ${questionsNeeded} questions
- Questions should test product knowledge, policies, and procedures
- Mix difficulty levels: beginner, intermediate, advanced
- Questions should be clear and specific
- Avoid yes/no questions - prefer open-ended questions
- Language: ${config.language}
- Format as JSON array with: {"id": "q1", "text": "question text", "category": "topic", "difficulty": "beginner|intermediate|advanced"}

Generate the questions:`

      const response = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          model: 'gpt-4o-mini',
          messages: [
            {
              role: 'system',
              content: 'You are an expert training question generator. Generate high-quality questions based on knowledge base content.'
            },
            {
              role: 'user',
              content: prompt
            }
          ],
          temperature: 0.8,
          max_tokens: 2000
        })
      })

      if (!response.ok) {
        throw new Error(`OpenAI API error: ${response.statusText}`)
      }

      const data = await response.json()
      const questionsText = data.choices[0]?.message?.content

      if (!questionsText) {
        throw new Error('No questions generated by AI')
      }

      // Parse JSON response
      const questions = JSON.parse(questionsText) as GeneratedQuestion[]

      return questions.slice(0, questionsNeeded) // Ensure we don't exceed needed amount

    } catch (error) {
      console.error('‚ùå AI question generation failed:', error)
      throw error
    }
  }

  /**
   * Generate fallback questions when knowledge base is unavailable
   */
  private generateFallbackQuestions(durationMinutes: number): GeneratedQuestion[] {
    const questionsNeeded = Math.max(10, Math.ceil(durationMinutes * 2))

    const baseQuestions = [
      { id: 'f1', text: 'What is our company\'s main product or service?', category: 'General', difficulty: 'beginner' as const },
      { id: 'f2', text: 'How would you describe our customer service philosophy?', category: 'Service', difficulty: 'beginner' as const },
      { id: 'f3', text: 'What are the key features of our flagship product?', category: 'Product', difficulty: 'intermediate' as const },
      { id: 'f4', text: 'How do you handle customer complaints?', category: 'Service', difficulty: 'intermediate' as const },
      { id: 'f5', text: 'What is our refund and return policy?', category: 'Policy', difficulty: 'beginner' as const },
      { id: 'f6', text: 'How do you identify customer needs during a consultation?', category: 'Sales', difficulty: 'advanced' as const },
      { id: 'f7', text: 'What safety protocols should be followed?', category: 'Safety', difficulty: 'intermediate' as const },
      { id: 'f8', text: 'How do you handle confidential customer information?', category: 'Privacy', difficulty: 'intermediate' as const },
      { id: 'f9', text: 'What are the signs of customer satisfaction?', category: 'Service', difficulty: 'beginner' as const },
      { id: 'f10', text: 'How do you escalate complex issues?', category: 'Process', difficulty: 'advanced' as const }
    ]

    // Repeat and shuffle to meet duration requirements
    const questions: GeneratedQuestion[] = []
    while (questions.length < questionsNeeded) {
      questions.push(...baseQuestions.slice(0, questionsNeeded - questions.length))
    }

    // Shuffle array
    for (let i = questions.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [questions[i], questions[j]] = [questions[j], questions[i]]
    }

    return questions.slice(0, questionsNeeded)
  }

  /**
   * Create a new avatar session
   */
  async createSession(data: CreateAvatarSessionData): Promise<AvatarSession> {
    try {
      const { data: session, error } = await supabaseAdmin
        .from('avatar_sessions')
        .insert({
          assignment_id: data.assignment_id,
          scenario_id: data.scenario_id,
          employee_id: data.employee_id,
          language: data.language,
          status: 'active',
          transcript: []
        })
        .select()
        .single()

      if (error) throw error

      console.log('‚úÖ Avatar session created:', session.id)
      return session

    } catch (error) {
      console.error('‚ùå Error creating avatar session:', error)
      throw error
    }
  }

  /**
   * Update an avatar session
   */
  async updateSession(sessionId: string, updates: UpdateAvatarSessionData): Promise<AvatarSession> {
    try {
      const { data: session, error } = await supabaseAdmin
        .from('avatar_sessions')
        .update({
          ...updates,
          updated_at: new Date().toISOString()
        })
        .eq('id', sessionId)
        .select()
        .single()

      if (error) throw error
      return session

    } catch (error) {
      console.error('‚ùå Error updating avatar session:', error)
      throw error
    }
  }

  /**
   * Get avatar session by ID
   */
  async getSession(sessionId: string): Promise<AvatarSession | null> {
    try {
      const { data: session, error } = await supabaseAdmin
        .from('avatar_sessions')
        .select('*')
        .eq('id', sessionId)
        .single()

      if (error) {
        if (error.code === 'PGRST116') return null
        throw error
      }

      return session

    } catch (error) {
      console.error('‚ùå Error getting avatar session:', error)
      return null
    }
  }

  /**
   * Get avatar sessions for an employee
   */
  async getEmployeeSessions(employeeId: string): Promise<AvatarSession[]> {
    try {
      const { data: sessions, error } = await supabaseAdmin
        .from('avatar_sessions')
        .select('*')
        .eq('employee_id', employeeId)
        .order('started_at', { ascending: false })

      if (error) throw error
      return sessions || []

    } catch (error) {
      console.error('‚ùå Error getting employee avatar sessions:', error)
      return []
    }
  }

  /**
   * Add entry to session transcript
   */
  async addTranscriptEntry(sessionId: string, entry: TranscriptEntry): Promise<void> {
    try {
      // Get current session
      const session = await this.getSession(sessionId)
      if (!session) throw new Error('Session not found')

      // Add new entry to transcript
      const updatedTranscript = [...session.transcript, entry]

      await this.updateSession(sessionId, {
        transcript: updatedTranscript
      })

    } catch (error) {
      console.error('‚ùå Error adding transcript entry:', error)
      throw error
    }
  }

  /**
   * Translate questions to target language
   */
  async translateQuestions(
    questions: GeneratedQuestion[],
    targetLanguage: SupportedLanguageCode
  ): Promise<GeneratedQuestion[]> {
    if (targetLanguage === 'en') {
      return questions // No translation needed for English
    }

    try {
      console.log(`üåç Translating ${questions.length} questions to ${targetLanguage}`)

      const questionTexts = questions.map(q => q.text)
      const prompt = `Translate the following questions to ${targetLanguage}. Maintain the same meaning and professional tone. Return only the translated questions, one per line:

${questionTexts.join('\n')}`

      const response = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          model: 'gpt-4o-mini',
          messages: [
            {
              role: 'system',
              content: 'You are a professional translator. Translate business training questions accurately while maintaining professional tone.'
            },
            {
              role: 'user',
              content: prompt
            }
          ],
          temperature: 0.2
        })
      })

      if (!response.ok) {
        console.error('Translation API error, keeping original questions')
        return questions
      }

      const data = await response.json()
      const translatedText = data.choices[0]?.message?.content

      if (!translatedText) {
        console.error('No translation received, keeping original questions')
        return questions
      }

      const translatedQuestions = translatedText.split('\n').filter(Boolean)

      // Map translated questions back to original structure
      const result = questions.map((question, index) => ({
        ...question,
        text: translatedQuestions[index] || question.text
      }))

      console.log(`‚úÖ Questions translated to ${targetLanguage}`)
      return result

    } catch (error) {
      console.error('‚ùå Translation failed, keeping original questions:', error)
      return questions
    }
  }

  /**
   * Get supported languages
   */
  getSupportedLanguages() {
    return SUPPORTED_LANGUAGES
  }

  /**
   * Validate language code
   */
  isValidLanguage(code: string): code is SupportedLanguageCode {
    return SUPPORTED_LANGUAGES.some(lang => lang.code === code)
  }

  /**
   * Calculate session statistics
   */
  calculateSessionStats(session: AvatarSession) {
    const transcript = session.transcript || []
    const userEntries = transcript.filter(entry => entry.speaker === 'user')
    const avatarEntries = transcript.filter(entry => entry.speaker === 'avatar')

    return {
      totalQuestions: avatarEntries.length,
      totalResponses: userEntries.length,
      responseRate: avatarEntries.length > 0 ? (userEntries.length / avatarEntries.length) * 100 : 0,
      avgResponseLength: userEntries.length > 0
        ? userEntries.reduce((sum, entry) => sum + entry.text.length, 0) / userEntries.length
        : 0,
      sessionDuration: session.duration_minutes,
      questionsPerMinute: session.duration_minutes > 0 ? avatarEntries.length / session.duration_minutes : 0
    }
  }
}

// Export singleton instance
export const avatarService = new AvatarService()